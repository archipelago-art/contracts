# Archipelago design

This document describes the design of the Archipelago system with a focus on
security and auditing. The intent is to clarify the intent of the system,
potential vulnerabilities, and mitigations that we've taken to address those.
This document is written for developers who are interested in understanding the
internals of Archipelago. End users do not need to read this document.

## Overview

The Archipelago contract system has three main pieces:

- the `ArchipelagoMarket` contract, an exchange for arbitrary ERC-721 tokens for
  arbitrary ERC-20 currencies (typically WETH);
- the `ITraitOracle` interface, implementors of which define semantics for
  _traits_ that ERC-721 tokens may have, and respond to queries about which
  tokens have which traits; and
- the various trait oracle implementations, including:
  - an `ArtblocksTraitOracle` with semantics of the Art Blocks platform, and
  - a generic `CircuitOracle` that enables composing other traits as Boolean
    formulas ("this trait OR that trait", etc.).

## Messages

Users authorize orders with a market by signing messages off-chain (for
externally owned accounts) or writing explicit message approvals into the
market's contract storage (for contracts like Gnosis Safes). Given signatures
for a bid and ask that are compatible, any user may call `fillOrder` to execute
the trade.

An ask (sell order) specifies a single token to be sold. There are two kinds of
bids (buy orders). A bid may specify a single token to be bought, just like an
ask. Or, a bid may specify a trait oracle and a trait, in which case it
represents an offer to purchase any single token matching that trait (according
to the specified oracle).

Bids and asks (collectively, orders) have some common metadata properties. An
order has a deadline, a Unix timestamp. An order also has a nonce, an arbitrary
`uint256`: each account may only fill one order with a given nonce. An account
can call a method on the `Market` contract to cancel all orders with a given
nonce. All cancellations are recorded on chain in the market contract storage.

We anticipate that these nonce semantics will enable a few emergent order
patterns:

- All-at-once cancellation of relaxed orders. If you (say) list a NFT for sale
  at 10 ETH, then list it again for 9 ETH at the same nonce, then again for 8
  ETH, then decide that actually you don't want to sell it, then you can cancel
  all these orders by cancelling their common nonce. (On OpenSea, you need to
  cancel each order individually.)

- Linked 1-of-_n_ orders. If you have two Fidenzas and would like to take _some_
  liquidity but retain exposure to the project, you can place asks for both of
  them with the same nonce, and be confident that only one will be filled.
  Likewise, you can do the same for bids.

- Linked _k_-of-_n_ orders, an extension of the above. If you have 5 NFTs and
  want to sell at most 3 of them, you can choose three nonces and publish a
  total of 15 asks, one for each NFT/nonce combination. Then, each nonce can be
  filled by at most one NFT sale, so you'll sell at most three of the tokens. If
  you want to cancel the whole operation, you can call `cancelNonces` once and
  list the three nonces.

Orders may specify a list of royalties, which are taken as a cut from the
seller's proceeds. For instance, this might include royalties for the artist,
the Art Blocks platform, and the Archipelago platform. A bid and an ask only
match if they specify exactly the same royalties. Each order may also specify
"extra royalties" to be paid by that side of the order. (That is: a bid may
specify extra royalties to be paid by the bidder, and an ask may specify extra
royalties to be paid by the seller.) Extra royalties do not have to match across
the two orders.

An ask may specify that the seller would like to be paid in ETH rather than
WETH. If so, the market contract will unwrap the buyer's WETH before sending the
proceeds to the seller. This only affects the seller, not any royalty
recipients. Correspondingly, a buyer may choose to pay in ETH rather than WETH
by calling `fillOrderEth`, which will wrap any attached ETH into WETH and send
it to the buyer before filling the order as normal.

## Signatures

The market and the Art Blocks trait oracle use a common framework for signature
validation, defined in `SignatureChecker.sol`. Messages are natively expressed
as EIP-712 typed data structs defined in `MarketMessages.sol` and
`ArtblocksTraitOracleMessages.sol`, and signatures may be provided either for
the EIP-712 hash (of a payload starting with `\x19\x01`) or for the hash of a
message generated by `eth_sign` as of [go-ethereum#2940][] (starting with
`\x19Ethereum Signed Message`). We call the latter format "legacy messages".

[go-ethereum#2940]: https://github.com/ethereum/go-ethereum/pull/2940

We support legacy messages because the EIP-712 spec and implementations are
marked as not yet finalized, and we've run into issues in the past using typed
data signatures with Ledger devices. The goal is to have a fallback method for
users who can't sign typed data messages or in case the spec changes in a way
that makes using `signTypedData_v4` inconvenient.

Legacy messages are intended to have the same security properties as EIP-712
messages. In particular, the payload to be signed is the concatenation of the
domain separator and the EIP-712 struct hash, just as they appear in an EIP-712
message. Only the message prefix differs.

We implement the EIP-712 struct hashing procedure manually, since it's
type-specific and doesn't yet have any Solidity built-ins. This is a possible
source of error: if we add a field to a struct but forget to add it to the
corresponding `structHash` function, then message signatures will not depend on
the value of that field, and so the value of that field would effectively be at
the discretion of whoever presents the signature. A bug of this form was fixed
in [6a2e0a7e8136].

[6a2e0a7e8136]:
  https://github.com/archipelago-art/contracts/commit/6a2e0a7e81368a629f549825cd1114321ff5fc0b

**Pre-launch check:** Verify that each `structHash` function depends on the
value of every field of the corresponding struct.

## Traits and oracles

A _trait oracle_ is a contract that implements the following `hasTrait` method:

```solidity
function hasTrait(
  IERC721 _tokenContract,
  uint256 _tokenId,
  bytes _trait
) external view returns (bool);

```

A _trait_ is an arbitrary bytestring, the semantics of which are defined by the
trait oracle. Oracles may define traits to answer simple point or range queries,
like "is this token a Fidenza?" or "is this token an Eternal Pump with at least
8 rings?". Trait oracles can also call out to other contracts to answer queries
like, "has this token's associated Adventurer Gold airdrop been claimed yet?".

Oracles can also define more complex structures for their traits. The
`CircuitOracle` interprets its `bytes _trait` as the encoding of an "underlying"
trait oracle address, a list of other traits to query on that underlying oracle,
and a Boolean circuit specifying how to combine the results. Thus, while the Art
Blocks oracle can answer queries like "is this an Archetype with the Paddle
palette?" or "is this an Archetype with the Blue Spider palette?", the circuit
oracle can answer questions like "is this an Archetype with _either_ the Paddle
palette or the Blue Spider palette?".

More details about our specific trait oracles appear below.

## Market

To cover:

- signing domain for bids/asks, both signatures and on-chain approvals
- impact of changes in trait oracle behavior on active traitset bids
- signature discovery service ("mempool")
- attack models: compromise of NFTs or ETH, orders filling with unintended
  semantics
- potential "pauser" role as a global panic button, which can be pre-committed
  to being burned at a later time

## Art Blocks trait oracle

To cover:

- threat model re: oracle signing key compromise
- threat model re: bad data from the Art Blocks API servers
- project/feature versioning
- feature trait finalization
- bit-packing for `traitMembers` and `traitFinalizations`
