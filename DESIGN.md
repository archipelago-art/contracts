# Archipelago design

This document describes the design of the Archipelago system with a focus on
security and auditing. The intent is to clarify the intent of the system,
potential vulnerabilities, and mitigations that we've taken to address those.
This document is written for developers who are interested in understanding the
internals of Archipelago. End users do not need to read this document.

## Overview

The Archipelago contract system has three main pieces:

- the `ArchipelagoMarket` contract, an exchange for arbitrary ERC-721 tokens for
  arbitrary ERC-20 currencies (typically WETH);
- the `ITraitOracle` interface, implementors of which define semantics for
  _traits_ that ERC-721 tokens may have, and respond to queries about which
  tokens have which traits; and
- the various trait oracle implementations, including:
  - an `ArtblocksOracle` with semantics of the Art Blocks platform, and
  - a generic `CircuitOracle` that enables composing other traits as Boolean
    formulas ("this trait OR that trait", etc.).

Users will approve the `ArchipelagoMarket` contract to manage their ERC-721 and
ERC-20 tokens; our chief security concern is ensuring that these tokens are not
transferred against their owners' intent. The oracle contracts are relevant to
this concern because they directly influence which orders the market will fill.

## Messages

Users authorize orders with a market by signing messages off-chain (for
externally owned accounts) or writing explicit message approvals into the
market's contract storage (for contracts like Gnosis Safes). Given signatures
for a bid and ask that are compatible, any user may call `fillOrder` to execute
the trade.

An ask (sell order) specifies a single token to be sold. There are two kinds of
bids (buy orders). A bid may specify a single token to be bought, just like an
ask. Or, a bid may specify a trait oracle and a trait, in which case it
represents an offer to purchase any single token matching that trait (according
to the specified oracle).

Bids and asks (collectively, orders) have some common metadata properties. An
order has a deadline, a Unix timestamp. An order also has a nonce, an arbitrary
`uint256`: each account may only fill one order with a given nonce. An account
can call a method on the `Market` contract to cancel all orders with a given
nonce. All cancellations are recorded on chain in the market contract storage.

We anticipate that these nonce semantics will enable a few emergent order
patterns:

- All-at-once cancellation of relaxed orders. If you (say) list a NFT for sale
  at 10 ETH, then list it again for 9 ETH at the same nonce, then again for 8
  ETH, then decide that actually you don't want to sell it, then you can cancel
  all these orders by cancelling their common nonce. (On OpenSea, you need to
  cancel each order individually.)

- Linked 1-of-_n_ orders. If you have two Fidenzas and would like to take _some_
  liquidity but retain exposure to the project, you can place asks for both of
  them with the same nonce, and be confident that only one will be filled.
  Likewise, you can do the same for bids.

- Linked _k_-of-_n_ orders, an extension of the above. If you have 5 NFTs and
  want to sell at most 3 of them, you can choose three nonces and publish a
  total of 15 asks, one for each NFT/nonce combination. Then, each nonce can be
  filled by at most one NFT sale, so you'll sell at most three of the tokens. If
  you want to cancel the whole operation, you can call `cancelNonces` once and
  list the three nonces.

Orders may specify a list of royalties, which are taken as a cut from the
seller's proceeds. For instance, this might include royalties for the artist,
the Art Blocks platform, and the Archipelago platform. A bid and an ask only
match if they specify exactly the same royalties. Each order may also specify
"extra royalties" to be paid by that side of the order. (That is: a bid may
specify extra royalties to be paid by the bidder, and an ask may specify extra
royalties to be paid by the seller.) Extra royalties do not have to match across
the two orders.

An ask may specify that the seller would like to be paid in ETH rather than
WETH. If so, the market contract will unwrap the buyer's WETH before sending the
proceeds to the seller. This only affects the seller, not any royalty
recipients. Correspondingly, a buyer may choose to pay in ETH rather than WETH
by calling `fillOrderEth`, which will wrap any attached ETH into WETH and send
it to the buyer before filling the order as normal.

## Signatures

The market and the Art Blocks trait oracle use a common framework for signature
validation, defined in `SignatureChecker.sol`. Messages are natively expressed
as EIP-712 typed data structs defined in `MarketMessages.sol` and
`ArtblocksOracleMessages.sol`, and signatures may be provided either for the
EIP-712 hash (of a payload starting with `\x19\x01`) or for the hash of a
message generated by `eth_sign` as of [go-ethereum#2940][] (starting with
`\x19Ethereum Signed Message`). We call the latter format "legacy messages".

[go-ethereum#2940]: https://github.com/ethereum/go-ethereum/pull/2940

We support legacy messages because the EIP-712 spec and implementations are
marked as not yet finalized, and we've run into issues in the past using typed
data signatures with Ledger devices. The goal is to have a fallback method for
users who can't sign typed data messages or in case the spec changes in a way
that makes using `signTypedData_v4` inconvenient.

Legacy messages are intended to have the same security properties as EIP-712
messages. In particular, the payload to be signed is the concatenation of the
domain separator and the EIP-712 struct hash, just as they appear in an EIP-712
message. Only the message prefix differs.

We implement the EIP-712 struct hashing procedure manually, since it's
type-specific and doesn't yet have any Solidity built-ins. This is a possible
source of error: if we add a field to a struct but forget to add it to the
corresponding `structHash` function, then message signatures will not depend on
the value of that field, and so the value of that field would effectively be at
the discretion of whoever presents the signature. A bug of this form was fixed
in [6a2e0a7e8136].

[6a2e0a7e8136]:
  https://github.com/archipelago-art/contracts/commit/6a2e0a7e81368a629f549825cd1114321ff5fc0b

**Pre-launch check:** Verify that each `structHash` function depends on the
value of every field of the corresponding struct.

## Traits and oracles

A _trait oracle_ is a contract that implements the following `hasTrait` method:

```solidity
function hasTrait(
  IERC721 _tokenContract,
  uint256 _tokenId,
  bytes _trait
) external view returns (bool);

```

A _trait_ is an arbitrary bytestring, the semantics of which are defined by the
trait oracle. Oracles may define traits to answer simple point or range queries,
like "is this token a Fidenza?" or "is this token an Eternal Pump with at least
8 rings?". Trait oracles can also call out to other contracts to answer queries
like, "has this token's associated Adventurer Gold airdrop been claimed yet?".

Oracles can also define more complex structures for their traits. The
`CircuitOracle` interprets its `bytes _trait` as the encoding of an "underlying"
trait oracle address, a list of other traits to query on that underlying oracle,
and a Boolean circuit specifying how to combine the results. Thus, while the Art
Blocks oracle can answer queries like "is this an Archetype with the Paddle
palette?" or "is this an Archetype with the Blue Spider palette?", the circuit
oracle can answer questions like "is this an Archetype with _either_ the Paddle
palette or the Blue Spider palette?".

More details about our specific trait oracles appear below.

## Market

There will be a single instance of the `ArchipelagoMarket` contract deployed.
Users are expected to approve this contract to manage their WETH and NFTs, so
its security surface is high.

The market accepts messages signed with a signing domain keyed against the
market contract address and the chain ID. The contract address is included in
the domain because on-chain cancellations are recorded in the market's contract
storage. If Alice approves an `ArchipelagoMarket` to manage her tokens,
publishes a signed ask, then cancels that ask on chain, and then later
authorizes a different instance of the `ArchipelagoMarket` contract, it is
desirable that the now-cancelled ask not be treated as valid on the new market.

When approving orders from another smart contract instead of an EOA, the domain
separator is not used, because the market's contract storage itself serves as
the signing domain.

Distribution and matching of signed orders does not happen on chain.

When filling an order with a trait bid, the market `staticcall`s out to the
trait oracle to check if the token from the ask has the trait specified in the
bid. Since the trait oracle is an arbitrary contract, the result of its
`hasTrait` call may change over time. If a trait oracle is somehow "compromised"
to return `true` inaccurately, orders may be filled with unintended semantics.

The market contract has an owner, an arbitrary address capable of calling
methods on the market. The owner does _not_ have authority to fill arbitrary
orders or transfer arbitrary tokens. The owner _can_ control royalty parameters,
specifying the required platform royalty amount and recipient. The owner can
also change whether the market is in "emergency shutdown" mode. In this mode,
any attempts to fill an order will fail. This is intended to be activated if we
discover a critical security flaw in the contract that jeopardizes users'
tokens.

When transferring ERC-721 tokens, the market only ever calls `safeTransferFrom`,
not `transferFrom`, to mitigate risk of locking tokens in contracts that can't
recover them.

## Art Blocks trait oracle

The Art Blocks trait oracle defines two kinds of traits: project traits and
feature traits. An Art Blocks _project_ is keyed by a small, sequential integer
and associated with zero or more tokens whose IDs are in a fixed range. For
instance, the project "Meridian" has ID `163`, and all Meridian tokens have IDs
between `163000000` and `163999999`, inclusive. Conversely, all tokens within
that range are Meridians. In fact, there will only ever be 1000 Meridians, so
only token IDs `163000000` through `163000999` (inclusive) can exist for this
project.

The Art Blocks oracle responds to trait queries by simply checking the token ID.

_Features_ are project-specific properties that may apply to some tokens. For
instance, some Meridians have the "Chromaticity: Monochrome" feature, while
others have the "Chromaticity: Duochrome" feature. A token can have more than
one feature, and a feature can apply to more than one token. Features of a token
are not known _a priori_ from only the token ID. Instead, they are computed off
chain by the Art Blocks platform and exposed through a centralized HTTP API.

### Signing and finalization semantics

We intend to store that data on chain on the Art Blocks trait oracle itself.
This dataset is not static: new projects are released regularly, and some
projects continue to occasionally mint new tokens. Once a token is minted, its
feature data _should_ be canonical and immutable. So, this on-chain dataset must
permit data to be added for new tokens.

At the same time, updates to this data are sensitive. Users can place a
high-value bid matching all tokens with a specific, highly valued feature. If
the on-chain feature dataset is compromised to incorrectly indicate that a less
valuable piece has this feature, then the high-value bid could be filled against
the low-value token. This would be a failure of the system.

We'll handle this as follows. The Art Blocks trait oracle contract has an owner,
and the owner can set an "oracle signer" address that is authorized to update
the feature data. This address will be controlled by a server that has access to
a known-accurate database of features. The server responds to requests to sign
messages indicating that certain tokens have certain features.

The contract will support freezing data on a per-feature basis for all tokens
below a certain token ID. For instance, the Chromie Squiggle project currently
has 9247 tokens out of a possible 10000, of which only 20 have the "Perfect
Spectrum" feature. It's possible that some of the 753 tokens that have not yet
been minted will also be perfect spectra, so we can't freeze this trait
entirely. But, once we have written data for the first 9247 tokens, we can
prevent the "Perfect Spectrum" feature from being added to or removed from
_those_ tokens specifically.

Once the data for a trait membership is finalized, it cannot be changed, even by
the oracle signer or the admin.

### Implementation overview

At an implementation level, feature trait membership is sharded by feature ID
and then packed by project-relative token index into 256-bit words. For example,
token `163000801` is token index 801 in the Meridian project. Its page is given
by `801 / 256 = 3`, and its offset is given by `801 % 256 = 33`. So, to check
whether Meridian #801 has the "Palette: Cave" feature, we test whether
`traitMembers[_traitId][801 / 256] & (1 << (801 % 256))` is nonzero (where
`_traitId` is essentially a hash of "Palette: Cave").

The implementation details of finalization aren't yet... finalized. It's easy to
write a solution with a message type that means, "finalize membership in feature
trait `t` for the first `n` tokens in this project, using whatever state is
currently on chain"---but this means that the validity of the message depends on
the current chain state, and if (e.g.) the chain forks to a block before one of
the memberships is written, the finalization message will still apply but will
finalize the wrong data. A family of approaches that avoids this problem
involves instead signing messages like "of the first `n` tokens in this project,
exactly `k` of them have trait `t`", which is a fact that does not depend on
chain state, and the contract can ignore the message if it does not yet have
membership tuples for `k` of the first `n` tokens. But tracking this state
efficiently is a bit harder. We're not yet sure what the right tradeoff is here.

(At the time of writing, the current implementation only allows finalizing full
256-long blocks of tokens for each trait. This works, but has weaker security
than we would like. For instance, while there are currently 9247 Squiggles, we
can only finalize traits for the first 9216 of them. The currently
implementation also never permits unsetting trait membership for a token.)

### Authorized signatures can be submitted by anyone

This system permits any account to present a trait update message signed by the
oracle signer. The reason is simple: there are currently ~150k tokens and ~30k
feature traits, with a total of ~1.4M feature trait membership tuples that can
be packed into ~80k 256-bit words. Directly writing all that to chain would cost
well over 100 ETH. However, writing a single storage word (or a few) is not that
expensive, and these are only actually needed when users _fill_ orders, not when
they sign them off-chain. So, we amortize the cost: the first user who wants to
fill a bid for a particular trait will also need to submit the trait membership
data to chain.

This means that we're manually processing ECDSA signatures instead of checking
`msg.sender` and using Ethereum's native authentication, and so we don't have
any built-in protection for replay attacks. We don't expect this to be a
problem. Once a message is signed, the facts that it represent should be valid
forever, and processing of the messages is idempotent. If the oracle signer key
is compromised, then the first action needs to be to use the admin key to rotate
to a new oracle, which prevents replay of any messages on the old signing key,
anyway.

The signing domain does include the chain ID and oracle address, so that we can
run testnet oracles with testnet Art Blocks data. Such testnet oracles should
really use a different signing address, too, but this is an extra layer of
defense.

### Feature versioning

As an extra eject button, trait IDs for both project traits and feature traits
include a version field. Thus, a feature trait actually encodes the hash of the
project ID, the feature name, and the trait version. The trait version is
expected to generally be 0, but if we can create a new trait at version 1 if
neccessary: say, if the upstream source of truth for token data changes, or if
the wrong values are written into storage for any transient reason.

Writing data for traits at newer versions does not change or invalidate data or
finalization for the same traits at older versions. In particular, orders made
against the old traits will still be honored. However, the frontend can
transparently create any new orders against the new version.

(_Should_ the admin have the ability to nix a trait entirely, such that its
`hasTrait` queries always return false? It's a lot of power, but only in the
direction of halting orders. Should the Art Blocks oracle have its own emergency
shutdown mechanism, like the market does?)

## Circuit oracle

A separate document describes the [design of the circuit oracle][circuit].

The `CircuitOracle` contract implementation uses inline assembly to
destructively consume from the front of bytestrings in EVM memory. During
operation, `bytes memory` values may not always be aligned to 32-byte addresses,
but we are not aware of anything that would make this problematic. It works fine
at the EVM level, and [Solidity's assembly conventions][solc-asm] does not
indicate that Solidity assumes that `bytes memory` values have any particular
alignment.

The `CircuitOracle` contract implementation also uses unchecked arithmetic and
some inline assembly for performance optimizations. This saves about 1000 gas on
some typical invocations. Most of the unchecked blocks are trivially, locally
safe (e.g., `require(_x > 0); unchecked { _x--; }`). All have `// SAFETY:`
justifications in comments.

[circuit]: https://hackmd.io/@wchargin/composite-oracles
[solc-asm]:
  https://docs.soliditylang.org/en/v0.8.11/assembly.html#conventions-in-solidity
